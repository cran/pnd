<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Andreï V. Kostyrka, University of Luxembourg" />


<title>Compatilibility of pnd with the syntax of numDeriv</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>

<style type="text/css">
p.abstract{
text-align: center;
font-weight: bold;
}
div.abstract{
margin: auto;
width: 90%;
}
</style>


<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
margin-bottom: 0em;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Compatilibility of pnd with the syntax of
numDeriv</h1>
<h4 class="author">Andreï V. Kostyrka, University of Luxembourg</h4>
<h4 class="date">Created: 2024-10-01, last modified: 2024-10-01,
compiled: 2025-03-01</h4>
<div class="abstract">
<p class="abstract">Abstract</p>
We describe the syntax of the widely popular <code>numDeriv</code>
package and show how the functions from the <code>pnd</code> package
recognise and handle the parameters related to numerical difference
computation. We draw parallels between the two, examine the differences,
and provide recommendations for new users.
</div>


<div id="TOC">
<ul>
<li><a href="#definitions-related-to-numerical-derivatives" id="toc-definitions-related-to-numerical-derivatives"><span class="toc-section-number">1</span> Definitions related to numerical
derivatives</a>
<ul>
<li><a href="#quick-start-reproducing-the-numderiv-vignette" id="toc-quick-start-reproducing-the-numderiv-vignette"><span class="toc-section-number">1.1</span> Quick start: reproducing the
numDeriv vignette</a></li>
<li><a href="#vectorisation-pitfalls" id="toc-vectorisation-pitfalls"><span class="toc-section-number">1.2</span> Vectorisation pitfalls</a></li>
</ul></li>
<li><a href="#breakdown-of-numderivgrad" id="toc-breakdown-of-numderivgrad"><span class="toc-section-number">2</span> Breakdown of
<code>numDeriv::grad</code></a>
<ul>
<li><a href="#handling-vectorised-inputs" id="toc-handling-vectorised-inputs"><span class="toc-section-number">2.1</span> Handling vectorised
inputs</a></li>
<li><a href="#approximation-method" id="toc-approximation-method"><span class="toc-section-number">2.2</span> Approximation method</a></li>
</ul></li>
<li><a href="#compatibility-implies-syntax-support-not-identical-values" id="toc-compatibility-implies-syntax-support-not-identical-values"><span class="toc-section-number">3</span> Compatibility implies syntax
support, not identical values</a>
<ul>
<li><a href="#zero-tolerances-may-cause-a-discontinuity" id="toc-zero-tolerances-may-cause-a-discontinuity"><span class="toc-section-number">3.1</span> Zero tolerances may cause a
discontinuity</a></li>
</ul></li>
<li><a href="#richardson-extrapolation" id="toc-richardson-extrapolation"><span class="toc-section-number">4</span> Richardson extrapolation</a></li>
<li><a href="#diagnostics" id="toc-diagnostics"><span class="toc-section-number">5</span> Diagnostics</a>
<ul>
<li><a href="#higher-order-accuracy-diagnostics" id="toc-higher-order-accuracy-diagnostics"><span class="toc-section-number">5.1</span> Higher-order accuracy
diagnostics</a></li>
</ul></li>
<li><a href="#references" id="toc-references"><span class="toc-section-number">6</span> References</a></li>
</ul>
</div>

<p>Load the packages first:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(pnd)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="co">#&gt; Parallel numerical derivatives v. 0.0.7 (2025-03-01).</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="co">#&gt; 4 physical cores for parallelism through mclapply forking are available on Linux.</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="fu">library</span>(numDeriv)</span></code></pre></div>
<p>Numerical derivatives are ubiquitous in applies statistics and
numerical methods, which is why many packages rely on streamlined
implementations of numerical derivatives as dependencies. The popular
<code>numDeriv</code> package by Paul Gilbert and Ravi Varadhan has 314
reverse dependencies as of October 2024. Its flexibility allowed other
packages to achieve better results by providing reasonable defaults and
the interface for fine-tuning that matters in numerical optimisation and
statistical inference. However, it has no parallel capabilities, which
is why it takes a lot of time to calculate numerical gradients with its
<code>grad</code> function.</p>
<p>This vignette showcases the similarities and differences between the
features of <code>numDeriv</code> and <code>pnd</code> for a smooth and
painless transition to the new package.</p>
<div id="definitions-related-to-numerical-derivatives" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Definitions related to
numerical derivatives</h1>
<p>In this section, we overview the key definitions that relate to the
functionality of <code>numDeriv</code>.</p>
<p>A <strong>derivative</strong> is the instantaneous rate of change of
a function (assuming its differentiability): <span class="math display">\[
f&#39;(x) = \frac{\mathrm{d} f}{\mathrm{d} x} := \lim_{h\to0}
\frac{f(x+h) - f(x)}{h}
\]</span></p>
<p>A <strong>numerical derivative</strong> is an approximation of the
expression above for a small fixed <em>h</em>. For a scalar function,
this approximation can be calculated with two function evaluations at
two different points yielding forward, central, and backward numerical
differences respectively: <span class="math display">\[
f_{\mathrm{FD}}&#39; (x, h) := \frac{f(x+h) - f(x)}{h}, \quad
f_{\mathrm{CD}}&#39; (x, h) := \frac{f(x+h) - f(x-h)}{2h}, \quad
f_{\mathrm{BD}}&#39; (x, h) := \frac{f(x) - f(x-h)}{h}
\]</span></p>
<p>These expressions involve only 2 terms, which limits their accuracy.
Ignoring machine errors due to rounding, the approximation error of
<span class="math inline">\(f_{\mathrm{FD}}&#39; (x, h)\)</span> and
<span class="math inline">\(f_{\mathrm{BD}}&#39; (x, h)\)</span> due to
Taylor series truncation is of the order <span class="math inline">\(O(h)\)</span>, and for <span class="math inline">\(f_{\mathrm{CD}}&#39; (x, h)\)</span>, it is <span class="math inline">\(O(h^2)\)</span>; since in practice, <span class="math inline">\(h\)</span> is very small, <span class="math inline">\(f_{\mathrm{CD}}&#39; (x, h)\)</span> is more
accurate. The degree to which <span class="math inline">\(h\)</span> is
raised in the error term is reflected in the naming: <span class="math inline">\(f_{\mathrm{FD}}&#39; (x, h)\)</span> and <span class="math inline">\(f_{\mathrm{BD}}&#39; (x, h)\)</span> are
<em>first-order-accurate</em>, while <span class="math inline">\(f_{\mathrm{CD}}&#39; (x, h)\)</span> is
<em>second-order-accurate</em>. Higher accuracy can be achieved by
computing more terms at extra points; the following approximation is
<em>fourth-order-accurate</em>: <span class="math display">\[
f_{\mathrm{CD},4}&#39; (x, h) := \frac{f(x - 2h) -8 f(x-h) + 8 f(x+h) -
f(x+2h)}{12h}
\]</span> Instead of <span class="math inline">\((x\pm h, x \pm
2h)\)</span>, any other convenient grid may be chosen. For the sake of
brevity, we do not compare the accuracy of these approximations and
refer to another vignette of this package, ‘Step-size-selection
algorithm benchmark’.</p>
<p>Instead of choosing a large evaluation grid in advance, the
researcher may instead compute the numerical derivative for several
different step sizes, <span class="math inline">\(h_1 &gt; h_2 &gt;
\ldots\)</span>, and combine multiple approximation to achieve higher
accuracy. This is known as <strong>Richardson extrapolation</strong>:
<span class="math display">\[
f_{\mathrm{Rich},4}&#39; (x, h_1, h_2) := \frac{(h_1 / h_2)^2
f_{\mathrm{CD}}&#39; (x, h_2) - f_{\mathrm{CD}}&#39; (x, h_1)}{(h_1 /
h_2)^2 - 1}
\]</span></p>
<p>If <span class="math inline">\(h_2 = h_1 / 2\)</span>, then, this
extrapolation formula reduces to <span class="math inline">\(f_{\mathrm{CD},4}&#39; (x, h_2)\)</span>. There is
a general solution to obtaining high-order-accurate derivatives from
function values evaluated at multiple points; see <span class="citation">Fornberg (1988)</span> for the solution and the
algorithm and <span class="citation">Kostyrka (2025)</span> for
derivation and stability analysis.</p>
<p><strong>NB.</strong> For accuracy order <span class="math inline">\(a
&gt; 2\)</span>, more than 2 function evaluations are required, which is
why the notion of ‘step size’ becomes unclear: it could signify the
initial step size in the Richardson extrapolation before the first
reduction, or the space between the elements of a symmetric grid <span class="math inline">\(\{\pm h, \pm 2h, \pm 3h, \ldots\}\)</span>
excluding zero, or the space between the elements of an equispaced
symmetric grid <span class="math inline">\(\{\pm h, \pm 3h, \pm 5h,
\ldots\}\)</span>, or some other measure describing the scaling of the
deviations around the point of interest.</p>
<p>Therefore, to estimate a derivative numerically, the user should be
able to supply the following tweaking parameters:</p>
<ul>
<li>The function <span class="math inline">\(f\)</span> and evaluation
point <span class="math inline">\(x\)</span>;</li>
<li>The side to determine whether forward, central, or backward
differences should be calculated;</li>
<li>The step size <span class="math inline">\(h\)</span>;</li>
<li>The desired accuracy order <span class="math inline">\(a\)</span>
for the truncation error to be <span class="math inline">\(O(h^a)\)</span> (requiring at least <span class="math inline">\(2a\)</span> evaluations). (Assuming, as described
in the note above, that it means either the initial step size or the
grid spacing based on the implementation.)</li>
</ul>
<p>Vector cases and, therefore, Jacobians can be approximated by
applying these formulæ to each coordinate of <span class="math inline">\(f\)</span>: <span class="math display">\[
J_{f_4}(x) :=
\begin{bmatrix}
    \frac{\partial f^{(1)}_4}{\partial x^{(1)}} &amp; \cdots &amp;
\frac{\partial f^{(1)}_4}{\partial x^{(n)}} \\
    \vdots                             &amp; \ddots &amp; \vdots \\
    \frac{\partial f^{(m)}_4}{\partial x^{(1)}} &amp; \cdots &amp;
\frac{\partial f^{(m)}_4}{\partial x^{(n)}}
\end{bmatrix}(x),
\]</span> where each partial derivative is estimated via finite
differences.</p>
<p>Both <code>numDeriv</code> and <code>pnd</code> allow the user to
choose these parameters. The simplified comparison is given below.</p>
<table>
<colgroup>
<col width="19%" />
<col width="51%" />
<col width="29%" />
</colgroup>
<thead>
<tr class="header">
<th>Argument</th>
<th><code>numDeriv::grad()</code> syntax</th>
<th><code>pnd::Grad()</code> syntax</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Function <span class="math inline">\(f\)</span></td>
<td><code>func</code></td>
<td><code>FUN</code></td>
</tr>
<tr class="even">
<td>Point <span class="math inline">\(x\)</span></td>
<td><code>x</code></td>
<td><code>x</code></td>
</tr>
<tr class="odd">
<td>Side</td>
<td><code>side</code></td>
<td><code>side</code></td>
</tr>
<tr class="even">
<td>Step size</td>
<td><code>method.args = list(d = ..., eps = ...)</code></td>
<td><code>h = ...</code></td>
</tr>
<tr class="odd">
<td>Accuracy order</td>
<td><code>method.args = list(r = ...)</code></td>
<td><code>acc.order = ...</code></td>
</tr>
</tbody>
</table>
<div id="quick-start-reproducing-the-numderiv-vignette" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Quick start:
reproducing the numDeriv vignette</h2>
<p>Examples of derivative and gradient calculation:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">grad</span>(sin, pi)  <span class="co"># Old</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="co">#&gt; [1] -1</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="fu">Grad</span>(sin, pi)  <span class="co"># New</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="co">#&gt; [1] -1</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;step.size&quot;)</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a><span class="co">#&gt; [1] 1.902377e-05</span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;step.size.method&quot;)</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="co">#&gt; [1] &quot;default&quot;</span></span></code></pre></div>
<p>Vector arguments are supported:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">grad</span>(sin, (<span class="dv">0</span><span class="sc">:</span><span class="dv">10</span>)<span class="sc">*</span><span class="dv">2</span><span class="sc">*</span>pi<span class="sc">/</span><span class="dv">10</span>)  <span class="co"># Old</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="co">#&gt;  [1]  1.000000  0.809017  0.309017 -0.309017 -0.809017 -1.000000 -0.809017</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="co">#&gt;  [8] -0.309017  0.309017  0.809017  1.000000</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="fu">Grad</span>(sin, (<span class="dv">0</span><span class="sc">:</span><span class="dv">10</span>)<span class="sc">*</span><span class="dv">2</span><span class="sc">*</span>pi<span class="sc">/</span><span class="dv">10</span>)  <span class="co"># New</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="co">#&gt;  [1]  1.000000  0.809017  0.309017 -0.309017 -0.809017 -1.000000 -0.809017</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="co">#&gt;  [8] -0.309017  0.309017  0.809017  1.000000</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;step.size&quot;)</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a><span class="co">#&gt;  [1] 6.055454e-06 3.804754e-06 7.609508e-06 1.141426e-05 1.521902e-05</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a><span class="co">#&gt;  [6] 1.902377e-05 2.282853e-05 2.663328e-05 3.043803e-05 3.424279e-05</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="co">#&gt; [11] 3.804754e-05</span></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;step.size.method&quot;)</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a><span class="co">#&gt; [1] &quot;default&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>func0 <span class="ot">&lt;-</span> <span class="cf">function</span>(x) <span class="fu">sum</span>(<span class="fu">sin</span>(x))</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="fu">grad</span>(func0, (<span class="dv">0</span><span class="sc">:</span><span class="dv">10</span>)<span class="sc">*</span><span class="dv">2</span><span class="sc">*</span>pi<span class="sc">/</span><span class="dv">10</span>)  <span class="co"># Old</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co">#&gt;  [1]  1.000000  0.809017  0.309017 -0.309017 -0.809017 -1.000000 -0.809017</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="co">#&gt;  [8] -0.309017  0.309017  0.809017  1.000000</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="fu">Grad</span>(func0, (<span class="dv">0</span><span class="sc">:</span><span class="dv">10</span>)<span class="sc">*</span><span class="dv">2</span><span class="sc">*</span>pi<span class="sc">/</span><span class="dv">10</span>)  <span class="co"># New</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="co">#&gt;  [1]  1.000000  0.809017  0.309017 -0.309017 -0.809017 -1.000000 -0.809017</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="co">#&gt;  [8] -0.309017  0.309017  0.809017  1.000000</span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;step.size&quot;)</span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a><span class="co">#&gt;  [1] 6.055454e-06 3.804754e-06 7.609508e-06 1.141426e-05 1.521902e-05</span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a><span class="co">#&gt;  [6] 1.902377e-05 2.282853e-05 2.663328e-05 3.043803e-05 3.424279e-05</span></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a><span class="co">#&gt; [11] 3.804754e-05</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;step.size.method&quot;)</span></span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a><span class="co">#&gt; [1] &quot;default&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>func1 <span class="ot">&lt;-</span> <span class="cf">function</span>(x) <span class="fu">sin</span>(<span class="dv">10</span><span class="sc">*</span>x) <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span>x)</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="fu">curve</span>(func1, <span class="at">from =</span> <span class="dv">0</span>, <span class="at">to =</span> <span class="dv">5</span>)</span></code></pre></div>
<p><img role="img" src="data:image/png;base64,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" width="10cm" /></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fl">2.04</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>numd1 <span class="ot">&lt;-</span> <span class="fu">grad</span>(func1, x)  <span class="co"># Old</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>numd2 <span class="ot">&lt;-</span> <span class="fu">Grad</span>(func1, x)  <span class="co"># New</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>numd3 <span class="ot">&lt;-</span> <span class="fu">Grad</span>(func1, x, <span class="at">h =</span> <span class="fu">gradstep</span>(func1, x)<span class="sc">$</span>par)  <span class="co"># New auto-selection</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>exact <span class="ot">&lt;-</span> <span class="dv">10</span><span class="sc">*</span><span class="fu">cos</span>(<span class="dv">10</span><span class="sc">*</span>x) <span class="sc">+</span> <span class="fu">exp</span>(<span class="sc">-</span>x)</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="fu">c</span>(<span class="at">Exact =</span> exact, <span class="at">Old =</span> numd1, <span class="at">New =</span> numd2, <span class="at">NewAuto =</span> numd2,</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>  <span class="at">OldErr =</span> (numd1<span class="sc">-</span>exact)<span class="sc">/</span>exact, <span class="at">NewErr =</span> (numd2<span class="sc">-</span>exact)<span class="sc">/</span>exact,</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>  <span class="at">NewAutoErr =</span> (numd3<span class="sc">-</span>exact)<span class="sc">/</span>exact)</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a><span class="co">#&gt;      Exact        Old        New    NewAuto     OldErr     NewErr NewAutoErr </span></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a><span class="co">#&gt;  3.335e-01  3.335e-01  3.335e-01  3.335e-01  8.469e-12 -1.530e-09 -1.475e-05</span></span></code></pre></div>
<p>Here, the relative error of the new approach with default settings is
worse than that of the old one. Nevertheless, the new implementation is
much faster and attains satisfactory accuracy with only 2 function
calls, whilst the <code>numDeriv</code> counterpart calls the function 9
times. If an appropriate step size is chosen (e.g. with the showcased
auto-selection procedure), then, the reliability of the result increases
while the derivative calculation still requires only 2 evaluations.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>numd1 <span class="ot">&lt;-</span> <span class="fu">grad</span>(func1, x)  <span class="co"># Old</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>numd2 <span class="ot">&lt;-</span> <span class="fu">Grad</span>(func1, x)  <span class="co"># New</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>numd3 <span class="ot">&lt;-</span> <span class="fu">Grad</span>(func1, x, <span class="at">h =</span> <span class="fu">sapply</span>(x, <span class="cf">function</span>(y) <span class="fu">gradstep</span>(func1, y)<span class="sc">$</span>par))</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>exact <span class="ot">&lt;-</span> <span class="dv">10</span><span class="sc">*</span><span class="fu">cos</span>(<span class="dv">10</span><span class="sc">*</span>x) <span class="sc">+</span> <span class="fu">exp</span>(<span class="sc">-</span>x)</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="fu">cbind</span>(<span class="at">Exact =</span> exact, <span class="at">Old =</span> numd1, <span class="at">New =</span> numd2, <span class="at">NewAuto =</span> numd2,</span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a> <span class="at">OldErr =</span> (numd1<span class="sc">-</span>exact)<span class="sc">/</span>exact, <span class="at">NewErr =</span> (numd2<span class="sc">-</span>exact)<span class="sc">/</span>exact,</span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>  <span class="at">NewAutoErr =</span> (numd3<span class="sc">-</span>exact)<span class="sc">/</span>exact)</span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a><span class="co">#&gt;        Exact    Old    New NewAuto     OldErr     NewErr NewAutoErr</span></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="co">#&gt;  [1,] -8.023 -8.023 -8.023  -8.023  6.118e-12 -6.443e-10 -1.064e-03</span></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a><span class="co">#&gt;  [2,]  4.216  4.216  4.216   4.216  6.271e-12 -2.370e-09 -9.944e-09</span></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a><span class="co">#&gt;  [3,]  1.592  1.592  1.592   1.592 -3.507e-12 -5.323e-09 -8.483e-05</span></span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a><span class="co">#&gt;  [4,] -6.651 -6.651 -6.651  -6.651  6.698e-12 -9.812e-09 -1.624e-02</span></span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a><span class="co">#&gt;  [5,]  9.656  9.656  9.656   9.656 -7.892e-13 -1.527e-08 -3.280e-08</span></span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a><span class="co">#&gt;  [6,] -9.522 -9.522 -9.522  -9.522 -4.610e-12 -2.200e-08 -1.965e-03</span></span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a><span class="co">#&gt;  [7,]  6.334  6.334  6.334   6.334  1.243e-11 -2.993e-08 -1.166e-06</span></span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a><span class="co">#&gt;  [8,] -1.104 -1.104 -1.104  -1.104  6.093e-12 -3.913e-08 -1.375e-04</span></span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a><span class="co">#&gt;  [9,] -4.481 -4.481 -4.481  -4.481  1.524e-12 -4.952e-08 -3.863e-03</span></span>
<span id="cb7-19"><a href="#cb7-19" tabindex="-1"></a><span class="co">#&gt; [10,]  8.623  8.623  8.623   8.623 -8.120e-13 -6.111e-08 -5.203e-07</span></span></code></pre></div>
<p>Examples of Jacobian calculation:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>func2 <span class="ot">&lt;-</span> <span class="cf">function</span>(x) <span class="fu">c</span>(<span class="fu">sin</span>(x), <span class="fu">cos</span>(x))</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>x <span class="ot">&lt;-</span> (<span class="dv">0</span><span class="sc">:</span><span class="dv">1</span>)<span class="sc">*</span><span class="dv">2</span><span class="sc">*</span>pi</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="fu">jacobian</span>(func2, x)</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2]</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a><span class="co">#&gt; [1,]    1    0</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a><span class="co">#&gt; [2,]    0    1</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a><span class="co">#&gt; [3,]    0    0</span></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a><span class="co">#&gt; [4,]    0    0</span></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a><span class="fu">Jacobian</span>(func2, x)</span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2]</span></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a><span class="co">#&gt; [1,]    1    1</span></span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a><span class="co">#&gt; [2,]    0    0</span></span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;step.size&quot;)</span></span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a><span class="co">#&gt; [1] 6.055454e-06 3.804754e-05</span></span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;step.size.method&quot;)</span></span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a><span class="co">#&gt; [1] &quot;default&quot;</span></span></code></pre></div>
<p>Examples of Hessian calculation:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fl">0.25</span> <span class="sc">*</span> pi</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="fu">hessian</span>(sin, x)</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="co">#&gt;            [,1]</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="co">#&gt; [1,] -0.7071068</span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>fun1e <span class="ot">&lt;-</span> <span class="cf">function</span>(x) <span class="fu">sum</span>(<span class="fu">exp</span>(<span class="dv">2</span><span class="sc">*</span>x))</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>)</span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="fu">hessian</span>(fun1e, x, <span class="at">method.args=</span><span class="fu">list</span>(<span class="at">d=</span><span class="fl">0.01</span>))</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="co">#&gt;              [,1]         [,2]         [,3]</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="co">#&gt; [1,] 2.955622e+01 2.583236e-15 1.620102e-11</span></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a><span class="co">#&gt; [2,] 2.583236e-15 1.613715e+03 5.400691e-12</span></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a><span class="co">#&gt; [3,] 1.620102e-11 5.400691e-12 8.810586e+04</span></span></code></pre></div>
</div>
<div id="vectorisation-pitfalls" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Vectorisation
pitfalls</h2>
<p>Vectorisation does not occur naturally in computer science; it is
rather a feature of a specially designed system than a natural property
of hardware or software. From the theoretical point of view, computers
are imperfect, restricted versions of Turing machine, analogous to
deterministic finite automata or linear bounded automata, capable of
reading and writing on a ‘tape’ of practically limited size provided a
sequence of instructions. At the hardware level, computers are capable
of executing a set of processor instructions, and these instructions are
typically supplied sequentially. In fact, vectorisation at the hardware
level is a relatively rare phenomenon because without a proper set-up,
it may lead to race conditions and non-deterministic behaviour. In
certain architectures or extensions (MMX, SSE, AVX), the data for
calculations can be set up in such a manner that one single instruction
processes multiple inputs, which can be achieved by packing the values
into one large register (e.g. four 32-bit numbers into one 128-bit SIMD
register). However, it is not easy to organise control flow in such a
manner, which is why most computer operations are carried out
sequentially.</p>
<p>The strong point of the <strong>R</strong> language is its
vectorisation. One may argue that this feature leads to its inefficiency
compared to, e.g., C++. Indeed, in C++, the overhead in loops is
typically irreducible and boils down to such hard-to-control factors as
jump instructions and data alignment to memory pages, whereas in R, the
overhead appear at each loop iteration due to environment manipulation,
extra assignment, name look-up, and occasional class-specific method
execution. On the other hand, not writing loops is useful when it would
take more human time to allocate memory and run a loop than computer
time to repeat redundant high-level operations under the hood: what
matters is the total time saved, machine and human combined. Finally, if
there is no explicit loop in a function because the latter relies
internally on <code>apply()</code> or calls C/C++ loops on high-level or
computationally heavy objects, then, the overhead due to the high-level
nature of R does not create substantial time losses compared to the
inner computations, and a vectorised function can be as slow as its
loop-based sequential version. This can be seen in the definition of
<code>do_vapply</code> in <code>apply.c</code>: the user-supplied
function is called in a loop; the implementation of
<code>SEXP lapply</code> also contains a C loop. Therefore, in an
efficient implementation of a vectorised function, the overhead is
minimised if most of the loops in which the input elements are processed
are low-level C/C++ loops with as few exchanges and high-level syntactic
embellishments as possible.</p>
<p>In <strong>R</strong>, it is harder to find something that is
<em>not</em> a vector. A scalar is just a special case of a vector –
with length 1: <code>identical(c(1), 1)</code> is <code>TRUE</code>.
Therefore, if a function is implemented in such a manner that it can
produce vector outputs for vector inputs <em>en masse</em>, it is
considered to be vectorised – with a caveat: dimensionality matters.
Consider the following classification:</p>
<table>
<colgroup>
<col width="31%" />
<col width="34%" />
<col width="34%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Scalar output</th>
<th>Vector output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Scalar input</td>
<td><span class="math inline">\(f_1\colon \mathbb{R} \mapsto
\mathbb{R}\)</span></td>
<td><span class="math inline">\(f_2\colon \mathbb{R} \mapsto
\mathbb{R}^m\)</span></td>
</tr>
<tr class="even">
<td>Vector input</td>
<td><span class="math inline">\(f_3\colon \mathbb{R}^n \mapsto
\mathbb{R}\)</span></td>
<td><span class="math inline">\(f_4\colon \mathbb{R}^n \mapsto
\mathbb{R}^m\)</span></td>
</tr>
</tbody>
</table>
<p>To compute a numerical derivative via finite differences, the
function must be evaluated at least twice. This means that, depending on
the parallel capabilities of a function, an efficient programmer should
implement numerical differentiation in such a manner that functions that
are vectorised at the low level take as many arguments in one call as
possible. Many calls of the same function with shorter arguments are
slower than one call with a long argument:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">system.time</span>(<span class="fu">replicate</span>(<span class="fl">1e5</span>, <span class="fu">sin</span>(<span class="fu">rnorm</span>(<span class="dv">10</span>))))</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a><span class="co">#&gt;   0.426   0.021   0.447</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="fu">system.time</span>(<span class="fu">sin</span>(<span class="fu">rnorm</span>(<span class="fl">1e6</span>)))</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="co">#&gt;   0.105   0.000   0.106</span></span></code></pre></div>
<p>The same phenomenon is observed in the real world with storage media:
copying 1000 files of size 1 MB each onto a flash drive is slower than
copying one 1-GB file obtained by concatenating said 1000 files.</p>
<p>The case of non-vectorised scalar output for scalar input, <span class="math inline">\(f_1\)</span>, can be vectorised trivially by
putting the function inside a loop or an <code>apply</code>-like
operation. Then, the preparation task for approximating <span class="math inline">\(f&#39;_1\)</span> is creating an array of values
at which the function will be evaluated in a loop or in a sequence of
parallel jobs (if <span class="math inline">\(f_1\)</span> is
computationally costly and the parallelisation overhead is small
compared to the evaluation time of <span class="math inline">\(f_1\)</span>). This is the case if <span class="math inline">\(f_1(x_0)\)</span> has length 1 for scalar <span class="math inline">\(x_0\)</span> and throws and error for vector <span class="math inline">\(x_0\)</span>.</p>
<p>If the function <span class="math inline">\(f_2\)</span> returns a
vector of length <span class="math inline">\(m\)</span> for scalar
input, then, its coordinate-wise derivatives make up a Jacobian with
dimensions <span class="math inline">\(m\times 1\)</span>. Such a
function should return an error for vector input, but a list of scalar
inputs should produce a list of vector outputs in a loop / apply-like
call that can be combined to obtain the <strong>Jacobian</strong>
approximation. The user should be aware of this function behaviour and
specifically request a Jacobian.</p>
<p>The case of <span class="math inline">\(f_3\)</span> is simple: if
the output has length 1 for vector input of length <span class="math inline">\(n\)</span>, then it implies that <span class="math inline">\(f_3\)</span> carries out a dimensionality-reducing
operation on the input elements. This implies that the numerical
derivatives with respect to each coordinate form the
<strong>gradient</strong> vector, and the user should call the function
that computes the gradient approximation. The numerical derivative with
respect to the first coordinate of <span class="math inline">\(x_0\)</span> is the weighted sum of <span class="math inline">\(f(x_0^{(1)} + h, x_0^{(2)}, \ldots)\)</span>,
<span class="math inline">\(f(x_0^{(1)} - h, x_0^{(2)},
\ldots)\)</span>, and potentially other values obtained at points where
only the first coordinate of <span class="math inline">\(x_0\)</span> is
altered. This is repeated for each input coordinate: e.g., for central
differences, <span class="math inline">\(2n\)</span> evaluations are
expected. The input is therefore a list of <span class="math inline">\(2n\)</span> argument vectors of length <span class="math inline">\(n\)</span>, and potentially more elements for
higher accuracy or higher derivation order.</p>
<p>The case with <span class="math inline">\(f_4\)</span> is the most
complicated one, and it is the reason behind the unexpected behaviour of
some of the functions in <code>numDeriv</code>. There are two sources of
danger in this implementation.</p>
<p><strong>1.</strong> If <span class="math inline">\(n = m\)</span>,
i.e. the user supplies a vector of length <span class="math inline">\(n\)</span> and the function returns a vector of
length <span class="math inline">\(n\)</span>, it is either due to the
true vectorisation of <span class="math inline">\(f_4\)</span> or due to
the fact that the output always has length <span class="math inline">\(n\)</span> regardless of the input, and such a
coincidence happened that the input had length <span class="math inline">\(n\)</span>. It is impossible to claim that <span class="math inline">\(f_4\colon \mathbb{R}^n \mapsto
\mathbb{R}^n\)</span> is a vectorised <span class="math inline">\(\vec
f_1\colon \mathbb{R} \mapsto \mathbb{R}\)</span> solely from the fact
that the output has length <span class="math inline">\(n\)</span> for
some input of length <span class="math inline">\(n\)</span>; multiple
lengths should be checked to confirm this.</p>
<p><strong>Example 1.</strong> Consider a function that computes the
quartiles of its input series. Its output always has length 3.
<code>numDeriv::grad</code> will believe that this function is a
vectorised scalar-valued one (i.e. <span class="math inline">\(\vec
f_1\)</span>) if <code>length(x) == 3</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="cf">function</span>(x) <span class="fu">quantile</span>(x, <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span><span class="sc">/</span><span class="dv">4</span>)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="fu">grad</span>(f, <span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>)</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="co">#&gt; Error in grad.default(f, x = 1:2): grad assumes a scalar valued function.</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="fu">grad</span>(f, <span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a><span class="co">#&gt; Error in grad.default(f, x = 1:4): grad assumes a scalar valued function.</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="fu">grad</span>(f, <span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>)</span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a><span class="co">#&gt; [1] 1.5000000 1.0000000 0.8333333</span></span></code></pre></div>
<p>It is therefore necessary to explicitly call its Jacobian:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">jacobian</span>(f, <span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>)</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3]</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="co">#&gt; [1,]  0.5  0.5  0.0</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="co">#&gt; [2,]  0.0  1.0  0.0</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a><span class="co">#&gt; [3,]  0.0  0.5  0.5</span></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a><span class="fu">jacobian</span>(f, <span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3] [,4]</span></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a><span class="co">#&gt; [1,] 0.25 0.75 0.00 0.00</span></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a><span class="co">#&gt; [2,] 0.00 0.50 0.50 0.00</span></span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a><span class="co">#&gt; [3,] 0.00 0.00 0.75 0.25</span></span></code></pre></div>
<p>This occurrence is more likely if <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> are small: for long inputs, a long
output vector of identical length implies almost certainly that <span class="math inline">\(f_4\)</span> is a vectorised <span class="math inline">\(\vec f_1\colon \mathbb{R} \mapsto
\mathbb{R}\)</span>, enabling efficient evaluation grid preparation to
keep the overhead due to loops as low as possible. <span class="math inline">\(\blacksquare\)</span></p>
<p><strong>2.</strong> If <span class="math inline">\(n\ne m\)</span>
but the function is internally parallelised coordinate-wise, then,
dimension checks based on the observed input and output lengths may be
flawed and result in unexpected behaviour. Technically, computing <span class="math inline">\(f_4\colon \mathbb{R}^n \mapsto
\mathbb{R}^m\)</span> can be seen as repeated application of <span class="math inline">\(f_2\colon \mathbb{R} \mapsto \mathbb{R}^m\)</span>
to a list of <span class="math inline">\(n\)</span> points, and its
parallelisation can be envisioned as such. However, if <span class="math inline">\(f_4\)</span> is implemented as stacked <span class="math inline">\(f_3\colon \mathbb{R}^n \mapsto
\mathbb{R}\)</span>, the output should be trated differently.</p>
<p>The Jacobian matrix can be created by column, stacking evaluations of
<span class="math inline">\(\frac{\partial}{\partial x}
f^{(i)}_4(x)\)</span> at each point <span class="math inline">\(x_1,
\ldots, x_n\)</span>, or by row, binding the transposed gradients <span class="math inline">\(\nabla^\intercal f^{(i)}_4(x)\)</span> of each
coordinate of <span class="math inline">\(f\)</span>. In
<strong>R</strong>, matrices can be created by column (default) or by
row, which determines the order in which the vector of length <span class="math inline">\(nm\)</span> is wrapped, but the exact method has
to be decided by the user or, in case of a package, inferred from the
function behaviour.</p>
<p><strong>Example 2.</strong> Consider <span class="math inline">\(f(x)
:= \begin{pmatrix} \sin x \\ \cos x \end{pmatrix}\)</span>. Note that
the functions <code>sin()</code> and <code>cos()</code> are vectorised
and can handle inputs of arbitrary lengths.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="cf">function</span>(x) <span class="fu">c</span>(<span class="fu">sin</span>(x), <span class="fu">cos</span>(x))</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="fu">f</span>(<span class="dv">1</span>)</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="co">#&gt; [1] 0.8414710 0.5403023</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="fu">jacobian</span>(f, <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>)</span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a><span class="co">#&gt;            [,1]       [,2]</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a><span class="co">#&gt; [1,]  0.5403023  0.0000000</span></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="co">#&gt; [2,]  0.0000000 -0.4161468</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a><span class="co">#&gt; [3,] -0.8414710  0.0000000</span></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a><span class="co">#&gt; [4,]  0.0000000 -0.9092974</span></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="fu">jacobian</span>(f, <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>)</span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a><span class="co">#&gt;            [,1]       [,2]       [,3]</span></span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a><span class="co">#&gt; [1,]  0.5403023  0.0000000  0.0000000</span></span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a><span class="co">#&gt; [2,]  0.0000000 -0.4161468  0.0000000</span></span>
<span id="cb13-14"><a href="#cb13-14" tabindex="-1"></a><span class="co">#&gt; [3,]  0.0000000  0.0000000 -0.9899925</span></span>
<span id="cb13-15"><a href="#cb13-15" tabindex="-1"></a><span class="co">#&gt; [4,] -0.8414710  0.0000000  0.0000000</span></span>
<span id="cb13-16"><a href="#cb13-16" tabindex="-1"></a><span class="co">#&gt; [5,]  0.0000000 -0.9092974  0.0000000</span></span>
<span id="cb13-17"><a href="#cb13-17" tabindex="-1"></a><span class="co">#&gt; [6,]  0.0000000  0.0000000 -0.1411200</span></span></code></pre></div>
<p>The Jacobian of <span class="math inline">\(f\)</span> is <span class="math inline">\((\cos x, -\sin x)\)</span>; therefore, the
expected output for <code>x0 = 1:2</code> is <span class="math inline">\(\begin{pmatrix} \cos 1 &amp; \cos 2 \\ -\sin 1
&amp; -\sin 2 \end{pmatrix}\)</span>. However, the output is a matrix
made of stacked diagonal matrices, and the result is wrong even when
<span class="math inline">\(n\ne m\)</span>!</p>
<p>The root cause of this error is the manner in which the vector-valued
function is defined: the length of the object
<code>c(sin(x), cos(x))</code> depends on the length of <code>x</code>:
if <code>length(x) == n</code>, then,
<code>length(c(sin(x), cos(x))) == 2*n</code>, and <strong>R</strong>
sees the output as a vector, not a matrix! Hence,
<code>jacobian(f, x0)</code> computes <code>f(x0)</code> to check the
function dimension, infers from the output
<code>f(c(sin(1:2), cos(1:2)))</code> that <span class="math inline">\(m
= 4\)</span>, <span class="math inline">\(n = 2\)</span>, which is
wrong, and pre-allocates a <span class="math inline">\(4\times
2\)</span> matrix of zeros for the results. <span class="math inline">\(\blacksquare\)</span></p>
<p>Therefore, without any <em>a priori</em> information about the
function inputs and outputs, the function that computes matrices of
derivatives should follow the following logic for determining dimensions
and handling potential errors:</p>
<ul>
<li>If the input argument <code>x</code> is a scalar, prepare an
evaluation grid in the form of a list, evaluate <code>f</code> on that
grid, and combine the result by row. For safety, ignore the fact that
<code>f</code> may be vectorised (like <code>sin(1:100)</code>) and may
handle vector inputs in some cases.
<ul>
<li>If the resulting matrix has 1 column, then, the function is either
<span class="math inline">\(f_1\colon \mathbb{R} \mapsto
\mathbb{R}\)</span> or <span class="math inline">\(f_3\colon
\mathbb{R}^n \mapsto \mathbb{R}\)</span> (since the output has length
1). Proceed with computing the derivative approximation via weighted
sums and return the derivative estimate. If a Jacobian was initially
requested, throw a warning that the output of <code>f</code> is a scalar
and gradient facilities should be used.</li>
<li>If the resulting matrix has more than 1 column, then, the function
is either <span class="math inline">\(f_2\colon \mathbb{R} \mapsto
\mathbb{R}^m\)</span> or <span class="math inline">\(f_4\colon
\mathbb{R}^n \mapsto \mathbb{R}^m\)</span>. Proceed with computing the
Jacobian approximation via weighted sums and return the row matrix of
the Jacobian estimate. If a gradient was initially requested, throw a
warning that the output of <code>f</code> is not a scalar and Jacobian
facilities should be used, or return an error that this case should be
handled by the Jacobian routine directly.</li>
</ul></li>
<li>If the input argument <code>x</code> is a vector, first, it must be
determined if <code>f</code> is vectorised <span class="math inline">\(\vec f_1\colon \mathbb{R} \mapsto
\mathbb{R}\)</span> or not. Call <code>f(x)</code> and examine the
output.
<ul>
<li>If the output has the same length as the input, it is highly likely
that <code>f</code> is vectorised – for a counterexample where it is
not, see Example 1 above showing that if the output is a vector, an
input of identical length may create the impression of vectorisation by
pure chance. This case can be checked by calling <code>f(x[1])</code>
and checking if the output has length 1. If not, a warning that the user
should request a Jacobian for a vector-valued function should be issued.
If this check is passed, proceed by assuming vectorisation and prepare
the evaluation grid as a long vector to reduce overhead.</li>
<li>If the output has length 1, then, the function is certainly <span class="math inline">\(f_3\colon \mathbb{R}^n \mapsto
\mathbb{R}\)</span>, and <code>f</code> should be applied to a list of
input vectors for gradient approximation. If the user requested a
Jacobian, a warning should be shown.</li>
<li>If the output length is neither <code>length(x)</code> nor
<code>1</code>, then <code>f</code> definitely belongs to the class
<span class="math inline">\(f_4\colon \mathbb{R}^n \mapsto
\mathbb{R}^m\)</span>. In this case, similarly to the the case with
scalar output, a list of vectors should be prepared as the evaluation
grid for Jacobian approximation. If the user requested a gradient, throw
a warning that the result is a Jacobian matrix with non-null
dimensions.</li>
</ul></li>
</ul>
<p>The user should know whether their function is scalar- or
vector-valued and call the gradient or Jacobian routine accordingly.
Nevertheless, a check should be carried out for dimensionality and
vectorisation.</p>
<p><strong>Gradient</strong> vectorisation detection is implemented as
follows. Firstly, compute <code>f(x)</code>.</p>
<ul>
<li>If <code>length(x) == 1</code> and <code>length(f(x)) == 1</code>,
create the evaluation grid as a list and use <code>apply</code>-like
calls because there is no knowledge whether <code>f</code> is <span class="math inline">\(f_1\)</span> or <span class="math inline">\(\vec
f_1\)</span>.</li>
<li>If <code>length(x) &gt; 1</code> and <code>length(f(x)) == 1</code>,
create the evaluation grid as a list and use <code>apply</code>-like
calls. This is the <span class="math inline">\(f_3\)</span> case.</li>
<li>If <code>length(x) &gt; 1</code> and
<code>length(f(x)) &gt; 1</code>, check if
<code>length(f(x)) == length(x)</code>, create the evaluation grid as a
vector and call <code>f</code> on it directly (the <span class="math inline">\(\vec f_1\)</span> case). Otherwise, return an
error that a Jacobian should be computed instead because the input
vector length is not equal to the output vector length.</li>
<li>If <code>length(x) == 1</code> and <code>length(f(x)) &gt; 1</code>,
return an error indicating that a Jacobian should be computed instead.
<ul>
<li>Checking if <code>length(f(x[1])) == 1</code> to avoid the error
from Example 2 above is unreliable because certain functions (especially
statistical ones) are not defined for scalars and might return an error.
Example: a function that returns the deviations from the trimmed mean
where the highest and the lowest values are forcibly deleted could fail
if the number of observations is less than 3. Similarly, if the input
length determined the number of observations for a model, having a
single observation may result in non-invertibility of the model matrix;
this error would not occur for long vector inputs.</li>
</ul></li>
</ul>
<p><strong>Jacobians</strong> should be checked similarly: compute
<code>f(x)</code> and check the following.</p>
<ul>
<li>If <code>length(f(x)) == 1</code>, return an error indicating that a
gradient should be computed instead.</li>
<li>If <code>length(x) &gt; 1</code> and
<code>length(f(x)) &gt; 1</code>, create the evaluation grid as a list
and call <code>f</code> on it directly. This is the <span class="math inline">\(\vec f_4\)</span> case. Even if the components of
<span class="math inline">\(f\)</span> are vectorised, applying
<code>f</code> to a list of points is the only safe option.</li>
</ul>
</div>
</div>
<div id="breakdown-of-numderivgrad" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Breakdown of
<code>numDeriv::grad</code></h1>
<div id="handling-vectorised-inputs" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Handling vectorised
inputs</h2>
<p>The implementation of <code>numDeriv::grad()</code> is clever: it
allows both vectorised and non-vectorised functions to be provided as
the input argument. Since gradients are defined for scalar functions, it
has to check whether the function of interest is scalar- or vector
values. This can be non-trivial with vectorised functions: although
<span class="math inline">\(\sin x\)</span> is as scalar function,
<code>sin(1:100)</code> will return a vector in R. Therefore,
<code>numDeriv::grad()</code> has to determine if the
<em>implementation</em> of <span class="math inline">\(f\)</span> is
<span class="math inline">\(\mathbb{R}^n \mapsto \mathbb{R}^n\)</span>
(scalar / vectorised scalar), or <span class="math inline">\(\mathbb{R}^n \mapsto \mathbb{R}\)</span> (scalar
multivariate function), or neither. Hence, functions like <span class="math inline">\(\mathbb{R} \mapsto \mathbb{R}^n\)</span> or <span class="math inline">\(\mathbb{R}^n \mapsto \mathbb{R}^m\)</span> are not
considered valid inputs.</p>
<p>Internally, <code>numDeriv::grad(f, x0, ...)</code> computes
<code>f0 = f(x0, ...)</code> and checks the length of <code>f0</code>.
For the input argument <code>x0</code> with <code>length(x0) = n</code>,
the allowed lengths of <code>f0</code> are either <code>1</code> (scalar
output) or <code>n</code> (vectorised output). Expressions such as
<code>grad(function(x) c(sin(x), cos(x)), x = 1)</code> return an error,
implying that for vector-valued function, the user might want to compute
a Jacobian. Similarly, <code>numDeriv::hessian()</code> checks the
dimensions of <code>f0 = f(x0, ...)</code> and only allows
non-vectorised functions with <code>length(f0) == 1</code>. Finally, the
function <code>numDeriv::genD</code> computes the first- and
second-derivative information (without cross-derivatives).</p>
<p>This check is not without its drawbacks: it may miscalculate function
dimensions. The implementation in <code>pnd::Grad()</code> handles the
edge cases that cause wrong outputs in
<code>numDeriv::grad()</code>.</p>
<p>The <code>pnd</code> package provides similar functions:
<code>Grad()</code> is a drop-in replacement for
<code>numDeriv::grad()</code>, <code>Hessian()</code> replaces
<code>numDeriv::hessian()</code>, <code>Jacobian()</code> subsumes
<code>numDeriv::jacobian()</code>, and <code>GenD()</code>, whilst not
corresponding to <code>numDeriv::genD()</code>, is the real workhorse
that computes arbitrary derivatives of arbitrary accuracy order.</p>
<p><strong>Example 1: correct dimensionality check results for
vector-valued functions.</strong></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>f2 <span class="ot">&lt;-</span> <span class="cf">function</span>(x) <span class="fu">c</span>(<span class="fu">sin</span>(x), <span class="fu">cos</span>(x))  <span class="co"># Vector output -&gt; gradient is unsupported</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a><span class="fu">grad</span>(f2, <span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a><span class="co">#&gt; Error in grad.default(f2, x = 1:4): grad assumes a scalar valued function.</span></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="fu">hessian</span>(f2, <span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a><span class="co">#&gt; Error in hessian.default(f2, x = 1:4): Richardson method for hessian assumes a scalar valued function.</span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a><span class="fu">Grad</span>(f2, <span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a><span class="co">#&gt; Error in Grad(f2, x = 1:4): Use &#39;Jacobian()&#39; instead of &#39;Grad()&#39; for vector-valued functions to obtain a matrix of derivatives.</span></span></code></pre></div>
<p>This check correctly identifies non-vectorised functions as well:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>f2 <span class="ot">&lt;-</span> <span class="cf">function</span>(x) <span class="fu">c</span>(<span class="fu">sum</span>(<span class="fu">sin</span>(x)), <span class="fu">sum</span>(<span class="fu">cos</span>(x)))</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="fu">grad</span>(f2, <span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a><span class="co">#&gt; Error in grad.default(f2, x = 1:4): grad assumes a scalar valued function.</span></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="fu">hessian</span>(f2, <span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a><span class="co">#&gt; Error in hessian.default(f2, x = 1:4): Richardson method for hessian assumes a scalar valued function.</span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a><span class="fu">jacobian</span>(f2, <span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a><span class="co">#&gt;            [,1]       [,2]       [,3]       [,4]</span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a><span class="co">#&gt; [1,]  0.5403023 -0.4161468 -0.9899925 -0.6536436</span></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a><span class="co">#&gt; [2,] -0.8414710 -0.9092974 -0.1411200  0.7568025</span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a><span class="fu">Grad</span>(f2, <span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a><span class="co">#&gt; Error in Grad(f2, x = 1:4): Use &#39;Jacobian()&#39; instead of &#39;Grad()&#39; for vector-valued functions to obtain a matrix of derivatives.</span></span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a><span class="fu">Jacobian</span>(f2, <span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a><span class="co">#&gt;            [,1]       [,2]       [,3]       [,4]</span></span>
<span id="cb15-15"><a href="#cb15-15" tabindex="-1"></a><span class="co">#&gt; [1,]  0.5403023 -0.4161468 -0.9899925 -0.6536436</span></span>
<span id="cb15-16"><a href="#cb15-16" tabindex="-1"></a><span class="co">#&gt; [2,] -0.8414710 -0.9092974 -0.1411200  0.7568025</span></span>
<span id="cb15-17"><a href="#cb15-17" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;step.size&quot;)</span></span>
<span id="cb15-18"><a href="#cb15-18" tabindex="-1"></a><span class="co">#&gt; [1] 6.055454e-06 1.211091e-05 1.816636e-05 2.422182e-05</span></span>
<span id="cb15-19"><a href="#cb15-19" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;step.size.method&quot;)</span></span>
<span id="cb15-20"><a href="#cb15-20" tabindex="-1"></a><span class="co">#&gt; [1] &quot;default&quot;</span></span></code></pre></div>
<p><strong>Example 2: valid input, invalid output in
<code>numDeriv</code>.</strong></p>
<p>If a function consists of individually vectorised components and
returns an output that differs in length from the input, then,
<code>numDeriv::jacobian</code> may return wrong results. Specifically,
the output should be stacked coordinate-wise gradients, but is made of
stacked diagonal matrices instead.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>f2 <span class="ot">&lt;-</span> <span class="cf">function</span>(x) <span class="fu">c</span>(<span class="fu">sin</span>(x), <span class="fu">cos</span>(x))</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a><span class="fu">grad</span>(f2, <span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a><span class="co">#&gt; Error in grad.default(f2, x = 1:4): grad assumes a scalar valued function.</span></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a><span class="fu">jacobian</span>(f2, <span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a><span class="co">#&gt;            [,1]       [,2]       [,3]       [,4]</span></span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="co">#&gt; [1,]  0.5403023  0.0000000  0.0000000  0.0000000</span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a><span class="co">#&gt; [2,]  0.0000000 -0.4161468  0.0000000  0.0000000</span></span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a><span class="co">#&gt; [3,]  0.0000000  0.0000000 -0.9899925  0.0000000</span></span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a><span class="co">#&gt; [4,]  0.0000000  0.0000000  0.0000000 -0.6536436</span></span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a><span class="co">#&gt; [5,] -0.8414710  0.0000000  0.0000000  0.0000000</span></span>
<span id="cb16-11"><a href="#cb16-11" tabindex="-1"></a><span class="co">#&gt; [6,]  0.0000000 -0.9092974  0.0000000  0.0000000</span></span>
<span id="cb16-12"><a href="#cb16-12" tabindex="-1"></a><span class="co">#&gt; [7,]  0.0000000  0.0000000 -0.1411200  0.0000000</span></span>
<span id="cb16-13"><a href="#cb16-13" tabindex="-1"></a><span class="co">#&gt; [8,]  0.0000000  0.0000000  0.0000000  0.7568025</span></span></code></pre></div>
</div>
<div id="approximation-method" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Approximation
method</h2>
<p>There are 3 methods implemented in <code>numDeriv</code> for gradient
calculation: ‘simple’, ‘Richardson’, and ‘complex’. For simplicity, the
formulæ given here assume scalar arguments; for vector arguments, these
calculations are done coordinate by coordinate.</p>
<ul>
<li><code>method = &quot;simple&quot;</code>, <code>numDeriv::grad()</code>
computes a fast one-sided difference with a fixed step size (the default
is 0.0001): <span class="math inline">\(f&#39;_{\mathrm{simple}} :=
\frac{f(x + h) - f(x)}{h}\)</span> or <span class="math inline">\(\frac{f(x) - f(x-h)}{h}\)</span>.</li>
<li><code>method = &quot;Richardson&quot;</code>, calls a routine for Richardson
extrapolation (described above).</li>
<li><code>method = &quot;complex&quot;</code> is valid only for those functions
for which the function may take complex inputs and handle complex
outputs. This limits the scope of this method to well-defined convenient
mathematical functions; this excludes the majority of applications in
statistics, biometrics, economics, and data science. However, if there
is such a function, then,
<code>numDeriv::grad(..., method = &quot;complex&quot;)</code> will return <span class="math inline">\(\Im[f(x + \mathrm{i} h)]/h\)</span>.</li>
</ul>
<p>This syntax of <code>numDeriv::grad</code> makes consistent step size
selection a chore because of the differences in method implementations.
If <code>method = &quot;simple&quot;</code>, the step size is
<code>method.args$eps</code> (defaults to <span class="math inline">\(10^{-4}\)</span>), and it is absolute. If
<code>method = &quot;Richardson&quot;</code>, the step size is the initial step
size in the Richardson extrapolation, and is computed as follows:</p>
<ul>
<li>If <span class="math inline">\(x \ge \mathrm{zero.tol}\)</span>,
then, the step size is relative, equal to <span class="math inline">\(h
= d|x|\)</span> with default <span class="math inline">\(d =
10^{-4}\)</span> and <span class="math inline">\(\mathrm{zero.tol} =
\sqrt{\epsilon_{\mathrm{mach}} / (7 \cdot 10^{-7})} \approx 1.8 \cdot
10^{-5}\)</span>;</li>
<li>If <span class="math inline">\(x &lt; \mathrm{zero.tol}\)</span>,
then, an absolute step is added to the relative one, resulting in the
effective step size <span class="math inline">\(h = d|x| +
\epsilon\)</span> with default <span class="math inline">\(\epsilon =
10^{-1}\)</span>.</li>
<li>A succession of finite differences is computed <span class="math inline">\(r\)</span> times (default <span class="math inline">\(r = 4\)</span>) where at each step, <span class="math inline">\(h\)</span> is reduced by a factor of <span class="math inline">\(v\)</span> (default <span class="math inline">\(v
= 2\)</span>).</li>
</ul>
<p>Technical remarks.</p>
<ul>
<li>If the derivative is one-sided, then, the step size is doubled.</li>
<li>If the finite difference value at any step is less than <span class="math inline">\(10^{-20}\)</span> in absolute value, it is set to
zero.</li>
</ul>
</div>
</div>
<div id="compatibility-implies-syntax-support-not-identical-values" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Compatibility implies
syntax support, not identical values</h1>
<div id="zero-tolerances-may-cause-a-discontinuity" class="section level2" number="3.1">
<h2><span class="header-section-number">3.1</span> Zero tolerances may
cause a discontinuity</h2>
<p>Why using <code>d*x + (abs(x)&lt;zero.tol) * eps</code> is
confusing</p>
</div>
</div>
<div id="richardson-extrapolation" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Richardson
extrapolation</h1>
<p>To dissect the Richardson extrapolation practically, it suffices to
make the function print its input arguments.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {<span class="fu">print</span>(x); <span class="fu">sin</span>(x)}</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>x0 <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>g1 <span class="ot">&lt;-</span> numDeriv<span class="sc">::</span><span class="fu">grad</span>(f, x0)</span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a><span class="co">#&gt; [1] 1</span></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a><span class="co">#&gt; [1] 1.0001</span></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a><span class="co">#&gt; [1] 0.9999</span></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a><span class="co">#&gt; [1] 1.00005</span></span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a><span class="co">#&gt; [1] 0.99995</span></span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a><span class="co">#&gt; [1] 1.000025</span></span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a><span class="co">#&gt; [1] 0.999975</span></span>
<span id="cb17-11"><a href="#cb17-11" tabindex="-1"></a><span class="co">#&gt; [1] 1.000012</span></span>
<span id="cb17-12"><a href="#cb17-12" tabindex="-1"></a><span class="co">#&gt; [1] 0.9999875</span></span>
<span id="cb17-13"><a href="#cb17-13" tabindex="-1"></a><span class="fu">print</span>(g1)</span>
<span id="cb17-14"><a href="#cb17-14" tabindex="-1"></a><span class="co">#&gt; [1] 0.5403023</span></span>
<span id="cb17-15"><a href="#cb17-15" tabindex="-1"></a></span>
<span id="cb17-16"><a href="#cb17-16" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;Auto-detected step:&quot;</span>, <span class="fu">step.SW</span>(sin, x0)<span class="sc">$</span>par, <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb17-17"><a href="#cb17-17" tabindex="-1"></a><span class="co">#&gt; Auto-detected step: 5e-06</span></span>
<span id="cb17-18"><a href="#cb17-18" tabindex="-1"></a>hgrid <span class="ot">&lt;-</span> <span class="dv">10</span><span class="sc">^</span><span class="fu">seq</span>(<span class="sc">-</span><span class="dv">10</span>, <span class="sc">-</span><span class="dv">4</span>, <span class="dv">1</span><span class="sc">/</span><span class="dv">32</span>)</span>
<span id="cb17-19"><a href="#cb17-19" tabindex="-1"></a>errors <span class="ot">&lt;-</span> <span class="fu">sapply</span>(hgrid, <span class="cf">function</span>(h) <span class="fu">Grad</span>(sin, x0, <span class="at">h =</span> h)) <span class="sc">-</span> <span class="fu">cos</span>(x0)</span>
<span id="cb17-20"><a href="#cb17-20" tabindex="-1"></a><span class="fu">plot</span>(hgrid, <span class="fu">abs</span>(errors), <span class="at">log =</span> <span class="st">&quot;xy&quot;</span>, <span class="at">cex =</span> <span class="fl">0.6</span>)</span></code></pre></div>
<p><img role="img" src="data:image/png;base64,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" width="10cm" /></p>
<p>Even with 4 Richardson extrapolations from 8 evaluations, the default
final step size is <code>1.25e-5</code>, which is larger than the
optimal step size, which is less than <code>1e-5</code> (visible from
the plot), the empirically determined step size <code>5e-6</code>, or
even the rule-of-thumb value <code>MachEps^(1/3)</code>.</p>
<p>The equivalence between <code>numDeriv</code> and <code>pnd</code>
implementations of the gradient can be established by computing the
optimal weights in the finite difference for the points in the
iterations of the Richardson extrapolation. In this example, the default
sequence of steps is <span class="math inline">\(\{h_i\}_{i=1}^4 =
10^{-4} / \{1, 2, 4, 8\}\)</span>, and the resulting stencil is <span class="math inline">\(\{\pm h_i\}_{i=1}^4\)</span>. The respective
weights can be calculated via <span class="math inline">\(fdCoef()\)</span>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">fdCoef</span>(<span class="at">stencil =</span> <span class="fu">c</span>(<span class="sc">-</span>(<span class="dv">2</span><span class="sc">^</span>(<span class="dv">3</span><span class="sc">:</span><span class="dv">0</span>)), <span class="dv">2</span><span class="sc">^</span>(<span class="dv">0</span><span class="sc">:</span><span class="dv">3</span>)))</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a><span class="fu">print</span>(b)</span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a><span class="co">#&gt; $stencil</span></span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a><span class="co">#&gt; [1] -8 -4 -2 -1  1  2  4  8</span></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a><span class="co">#&gt; $weights</span></span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a><span class="co">#&gt;          x-8h          x-4h          x-2h          x-1h          x+1h </span></span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a><span class="co">#&gt;  2.204586e-05 -3.703704e-03  1.185185e-01 -7.223986e-01  7.223986e-01 </span></span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a><span class="co">#&gt;          x+2h          x+4h          x+8h </span></span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a><span class="co">#&gt; -1.185185e-01  3.703704e-03 -2.204586e-05 </span></span>
<span id="cb18-11"><a href="#cb18-11" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb18-12"><a href="#cb18-12" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;remainder.coef&quot;)</span></span>
<span id="cb18-13"><a href="#cb18-13" tabindex="-1"></a><span class="co">#&gt; [1] -0.01128748</span></span>
<span id="cb18-14"><a href="#cb18-14" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;accuracy.order&quot;)</span></span>
<span id="cb18-15"><a href="#cb18-15" tabindex="-1"></a><span class="co">#&gt; requested effective </span></span>
<span id="cb18-16"><a href="#cb18-16" tabindex="-1"></a><span class="co">#&gt;        NA         8 </span></span>
<span id="cb18-17"><a href="#cb18-17" tabindex="-1"></a><span class="co">#&gt; attr(,&quot;expansion&quot;)</span></span>
<span id="cb18-18"><a href="#cb18-18" tabindex="-1"></a><span class="co">#&gt; [1] &quot;f&#39; - 1.1287e-02 f^(9) + ...&quot;</span></span></code></pre></div>
<p>Here, the weights on the outermost points – the first step of the
iteration with <span class="math inline">\(h_1\)</span> – are minuscule
(<code>2.2e-5</code>). The relative importance of each iteration for
this specific function at this specific point can be found from the
equation <span class="math display">\[
f&#39;_{\mathrm{Rich,8}} =
\frac{f(x-h_1)-168f(x-h_2)+5376f(x-h_3)-32768f(x-h_4)+32768f(x+h_4)-5376f(x+h_3)+168f(x+h_3)-1f(x+h_4)}{45360h}
= \sum_{i=1}^4 w_{i}[f(x + h_i) - f(x + h_i)],
\]</span> where <span class="math inline">\(\{w_i\}_{i=1}^4 \approx
\{0.608, -0.0997, +0.0031, -0.00002\}\)</span>. This result can be
calculated numerically:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>fd <span class="ot">&lt;-</span> <span class="fu">sin</span>(x0 <span class="sc">+</span> b<span class="sc">$</span>stencil <span class="sc">/</span> <span class="fl">8e4</span>) <span class="sc">*</span> b<span class="sc">$</span>weights</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="fu">abs</span>(fd[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>]) <span class="sc">/</span> <span class="fu">sum</span>(<span class="fu">abs</span>(fd[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>]))</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a><span class="co">#&gt;         x-8h         x-4h         x-2h         x-1h </span></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a><span class="co">#&gt; 2.609937e-05 4.384834e-03 1.403170e-01 8.552721e-01</span></span></code></pre></div>
<p>The absolute contribution of each term is proportional to specific
terms of a certain polynomial. Practically, it implies that the weights
of the summation terms further away from the point of interest decay
exponentially (up to a certain constant), and similar accuracy can be
achieved with fewer evaluations. In this example, 85% of the sum is
defined by the finite difference with <span class="math inline">\(h_4\)</span>, and 14% with <span class="math inline">\(h_3\)</span>. Therefore, the following function is
twice as cheap, and the dis</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>g2 <span class="ot">&lt;-</span> <span class="fu">Grad</span>(f, x0, <span class="at">h =</span> <span class="fl">1.25e-05</span>, <span class="at">acc.order =</span> <span class="dv">4</span>, <span class="at">vectorised =</span> <span class="cn">TRUE</span>, <span class="at">report =</span> <span class="dv">0</span>)</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a><span class="co">#&gt; [1] 1</span></span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a><span class="co">#&gt; [1] 0.9999750 0.9999875</span></span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a><span class="co">#&gt; [1] 0.999975</span></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a><span class="co">#&gt; [1] 0.9999875</span></span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a><span class="co">#&gt; [1] 1.000012</span></span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a><span class="co">#&gt; [1] 1.000025</span></span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a><span class="fu">print</span>(g2)</span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a><span class="co">#&gt; [1] 0.5403023</span></span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a><span class="fu">c</span>(<span class="at">diff =</span> g1 <span class="sc">-</span> g2, <span class="at">Error8 =</span> <span class="fu">cos</span>(x0) <span class="sc">-</span> g1, <span class="at">Error4 =</span> <span class="fu">cos</span>(x0) <span class="sc">-</span> g2)</span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a><span class="co">#&gt;          diff        Error8        Error4 </span></span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a><span class="co">#&gt; -2.377543e-12  4.636624e-12  2.259082e-12</span></span></code></pre></div>
<p>In this example, the approximation errors from the Richardson
extrapolation and a much cheaper weighted sum have the same order of
magnitude.</p>
<p><strong>Conclusion:</strong> choosing a large initial step and
subsequently shrinking it is wasteful because similar, if not
indistinguishable, accuracy can be achieved with twice as few
evaluations with a reasonably chosen bandwidth. If the function is to be
evaluated many times, selecting the optimal step size via a data-driven
procedure not only saves time whilst attaining comparable accuracy but
also provides opportunities for speed-up via parallel evaluation of the
function on the grid. Richardson extrapolation, on the other hand, is
typically computed in a loop, and since its fully parallelised
implementation is fully subsumed by the weighted-sum approach, the new
package does not dedicate any special numerical routine to this
particular case.</p>
</div>
<div id="diagnostics" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Diagnostics</h1>
<div id="higher-order-accuracy-diagnostics" class="section level2" number="5.1">
<h2><span class="header-section-number">5.1</span> Higher-order accuracy
diagnostics</h2>
<p>The term ‘extrapolation group’ can be found, e.g., in <span class="citation">Lindfield and Penny (1989)</span>, where it is used in
sections on numerical integration and differentiation and describes
sub-intervals on which polynomials of different degrees are fitted to
improve approximation accuracy. Computer programmes in the 1980s were
often optimised for memory use and size, not necessarily for ease of
interpretation or transparency of their correspondence to the
theoretical relationships that they were translating into numbers.
Therefore, a reader might get confused by the terms ‘extrapolation
group’, ‘improvement iteration’, and ‘accuracy order’. The
<code>pnd</code> package aims to provide more straightforward diagnostic
information.</p>
<p>Suppose that one wants to compute the derivative of <span class="math inline">\(f(x) = x^7\)</span> at <span class="math inline">\(x_0 = 1\)</span> – therefore, the true derivative
value is <span class="math inline">\(f&#39;(1) = 6\)</span>. The
following code effectively debugs <code>numDeriv::grad()</code> and
shows how many values are computed (we choose the initial step size
<span class="math inline">\(h=2^{-10} = 1/1024\)</span> to avoid any
representation error of <span class="math inline">\(x_0+h\)</span>):</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>f <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {<span class="fu">print</span>(x, <span class="at">digits =</span> <span class="dv">16</span>); x<span class="sc">^</span><span class="dv">9</span>} </span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>fp1 <span class="ot">&lt;-</span> numDeriv<span class="sc">::</span><span class="fu">grad</span>(f, <span class="at">x =</span> <span class="dv">1</span>, <span class="at">method.args =</span> <span class="fu">list</span>(<span class="at">r =</span> <span class="dv">4</span>, <span class="at">d =</span> <span class="dv">2</span><span class="sc">^-</span><span class="dv">10</span>, <span class="at">show.details =</span> <span class="cn">TRUE</span>))</span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a><span class="co">#&gt; [1] 1</span></span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a><span class="co">#&gt; [1] 1.0009765625</span></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a><span class="co">#&gt; [1] 0.9990234375</span></span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a><span class="co">#&gt; [1] 1.00048828125</span></span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a><span class="co">#&gt; [1] 0.99951171875</span></span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a><span class="co">#&gt; [1] 1.000244140625</span></span>
<span id="cb21-9"><a href="#cb21-9" tabindex="-1"></a><span class="co">#&gt; [1] 0.999755859375</span></span>
<span id="cb21-10"><a href="#cb21-10" tabindex="-1"></a><span class="co">#&gt; [1] 1.0001220703125</span></span>
<span id="cb21-11"><a href="#cb21-11" tabindex="-1"></a><span class="co">#&gt; [1] 0.9998779296875</span></span>
<span id="cb21-12"><a href="#cb21-12" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb21-13"><a href="#cb21-13" tabindex="-1"></a><span class="co">#&gt;  first order approximations </span></span>
<span id="cb21-14"><a href="#cb21-14" tabindex="-1"></a><span class="co">#&gt;               [,1]</span></span>
<span id="cb21-15"><a href="#cb21-15" tabindex="-1"></a><span class="co">#&gt; [1,] 9.00008010876</span></span>
<span id="cb21-16"><a href="#cb21-16" tabindex="-1"></a><span class="co">#&gt; [2,] 9.00002002717</span></span>
<span id="cb21-17"><a href="#cb21-17" tabindex="-1"></a><span class="co">#&gt; [3,] 9.00000500679</span></span>
<span id="cb21-18"><a href="#cb21-18" tabindex="-1"></a><span class="co">#&gt; [4,] 9.00000125170</span></span>
<span id="cb21-19"><a href="#cb21-19" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb21-20"><a href="#cb21-20" tabindex="-1"></a><span class="co">#&gt;  Richarson improvement group No.  1 </span></span>
<span id="cb21-21"><a href="#cb21-21" tabindex="-1"></a><span class="co">#&gt;               [,1]</span></span>
<span id="cb21-22"><a href="#cb21-22" tabindex="-1"></a><span class="co">#&gt; [1,] 8.99999999997</span></span>
<span id="cb21-23"><a href="#cb21-23" tabindex="-1"></a><span class="co">#&gt; [2,] 9.00000000000</span></span>
<span id="cb21-24"><a href="#cb21-24" tabindex="-1"></a><span class="co">#&gt; [3,] 9.00000000000</span></span>
<span id="cb21-25"><a href="#cb21-25" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb21-26"><a href="#cb21-26" tabindex="-1"></a><span class="co">#&gt;  Richarson improvement group No.  2 </span></span>
<span id="cb21-27"><a href="#cb21-27" tabindex="-1"></a><span class="co">#&gt;      [,1]</span></span>
<span id="cb21-28"><a href="#cb21-28" tabindex="-1"></a><span class="co">#&gt; [1,]    9</span></span>
<span id="cb21-29"><a href="#cb21-29" tabindex="-1"></a><span class="co">#&gt; [2,]    9</span></span>
<span id="cb21-30"><a href="#cb21-30" tabindex="-1"></a><span class="fu">print</span>(fp1, <span class="at">digits =</span> <span class="dv">16</span>)</span>
<span id="cb21-31"><a href="#cb21-31" tabindex="-1"></a><span class="co">#&gt; [1] 9.000000000000064</span></span></code></pre></div>
<p>In total, the function was called 9 times: 1 for the initial
dimensionality check and 2 times per each of the 4 iterations (since ).
In this implementation, the terminology differs from the textbook that
it is referring to: <code>numDeriv</code>‘s ‘first-order approximations’
correspond to Lindfield &amp; Penny’s ‘Group 1’, ‘Richarsdon improvement
group No. 1’ to LP’s ‘Group 2’, and the final output returned by
<code>grad()</code> would be ‘Group 4’.</p>
<p>In central differences, <span class="math inline">\(f(x_0)\)</span>
is not used; with 8 symmetric evaluations, the truncation error of the
result is <span class="math inline">\(O(h^8)\)</span>.
<strong>Therefore, the standard textbook results about the optimal step
size for central first differences being proportional to</strong> <span class="math inline">\(\epsilon_{\mathrm{mach}}^{1/3}\)</span>
<strong>are not applicable to</strong> <code>numDeriv::grad()</code>
<strong>because the default accuracy order is 8 and the step size of the
order</strong> <span class="math inline">\(\epsilon_{\mathrm{mach}}^{1/3}\)</span> <strong>is
appropriate in this case</strong>.</p>
<p>With <code>pnd</code>, there is no need to re-define the function to
save its computed values because both the grid and the function values
are returned as the attribute.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="co"># f &lt;- function(x) x^9</span></span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a><span class="co"># fp2 &lt;- pnd::Grad(f, x = 1, h = &quot;SW&quot;, acc.order = 8, vectorised1d = TRUE, report = 2)</span></span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a><span class="co"># print(attributes(fp2)$step.search$iterations, digits = 16)</span></span></code></pre></div>
<p>This highlights an important difference between the two packages:</p>
<ul>
<li><code>numDeriv::grad()</code> starts at a relatively large step size
<span class="math inline">\(h = 10^{-4} \cdot \max(|x_0|, 1)\)</span>
and repeatedly shrinks it, yielding an exponentially decreasing sequence
<span class="math inline">\(h, h / v, h / v^2, \ldots\)</span> using the
same reduction factor <span class="math inline">\(v\)</span> to attain
the desired accuracy order <span class="math inline">\(a = 2v\)</span> –
<strong>slow due to many evaluations, but rather accurate</strong>;</li>
<li><code>pnd::Grad()</code> starts at the rule-of-thumb step size of
the correct order <span class="math inline">\(\epsilon_{\text{mach}}^{1/(1+a)}\)</span>. By
default, it computes central derivatives <span class="math inline">\(f&#39;_{\mathrm{CD}}(x, h)\)</span> with accuracy
order <span class="math inline">\(a = 2\)</span> – <strong>fast due to
fewer evaluations, smaller default step size that agrees with numerical
analysis literature, estimates of the approximation error are
provided</strong>. If accuracy order <span class="math inline">\(a &gt;
2\)</span> is requested, then, the evaluation grid is linear: <span class="math inline">\(x \pm h, x \pm 2h, x \pm 3h, \ldots\)</span>.</li>
</ul>
<p>Finally, the method argument <code>show.details = TRUE</code> is
ignored for Hessians in <code>numDeriv</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="cf">function</span>(x) <span class="fu">sum</span>(<span class="fu">sin</span>(x))</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a><span class="fu">hessian</span>(g, <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="at">method.args =</span> <span class="fu">list</span>(<span class="at">show.details =</span> <span class="cn">TRUE</span>))</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a><span class="co">#&gt;               [,1]          [,2]          [,3]</span></span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a><span class="co">#&gt; [1,] -8.414710e-01  4.072455e-14 -2.864747e-13</span></span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a><span class="co">#&gt; [2,]  4.072455e-14 -9.092974e-01  1.358524e-14</span></span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a><span class="co">#&gt; [3,] -2.864747e-13  1.358524e-14 -1.411200e-01</span></span></code></pre></div>
<p>This is due to the fact that the <code>hessian.default()</code>
method calls <code>genD()</code>, but the latter never checks if
<code>method.args$show.details</code> is <code>TRUE</code> in the loops
where the extrapolation is carried out. This silent operation mode was
probably implemented to avoid output verbosity since there are many
elements in matrices. Nevertheless, any user who has not looked at the
source code of <code>hessian()</code> would be puzzled by this
unexpected behaviour because the manual of <code>?hessian</code>
explicitly refers to <code>?grad</code> and says that
<code>method.args</code> is passed to <code>grad</code>.</p>
<p></p>
</div>
</div>
<div id="references" class="section level1" number="6">
<h1><span class="header-section-number">6</span> References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fornberg1988generation" class="csl-entry">
Fornberg, Bengt. 1988. <span>“Generation of Finite Difference Formulas
on Arbitrarily Spaced Grids.”</span> <em>Mathematics of Computation</em>
51 (184): 699–706. <a href="https://doi.org/10.1090/S0025-5718-1988-0935077-0">https://doi.org/10.1090/S0025-5718-1988-0935077-0</a>.
</div>
<div id="ref-kostyrka2025what" class="csl-entry">
Kostyrka, Andreï V. 2025. <span>“What Are You Doing, Step Size: Fast
Computation of Accurate Numerical Derivatives with Finite
Precision.”</span> Working paper.
</div>
<div id="ref-lindfield1989microcomputers" class="csl-entry">
Lindfield, G. R., and J. E. T. Penny. 1989. <em>Microcomputers in
Numerical Analysis</em>. Halsted Press.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
